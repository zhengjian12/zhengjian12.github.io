<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/09/java基础/" class="article-date">
  <time datetime="2019-04-09T03:16:30.424Z" itemprop="datePublished">2019-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、基础知识：<br>1、JVM、JRE和JDK的区别：<br>JVM(Java Virtual Machine):java虚拟机，用于保证java的跨平台的特性。<br>java语言是跨平台，jvm不是跨平台的。<br>JRE(Java Runtime Environment):java的运行环境,包括jvm+java的核心类库。<br>JDK(Java Development Kit):java的开发工具,包括jre+开发工具</p>
<p>2、环境变量path和classpath的作用是什么？<br>(1)path是配置Windows可执行文件的搜索路径，即扩展名为.exe的程序文件所在的目录，<br>用于指定DOS窗口命令的路径。<br>(2)Classpath是配置class文件所在的目录，用于指定类搜索路径，JVM就是通过它来寻找该类的class类文件的。    </p>
<p>3、变量有什么用？为什么要定义变量？什么时候用？<br>答：变量的作用：用来存储数据。<br>为什么要定义变量：用来不断的存放同一类型的常量，并可以重复使用</p>
<p>4、&amp;和&amp;&amp;的区别?<br>答：（1）&amp;&amp;会出现短路，如果可以通过第一个表达式判断出整个表达式的结果，则不继续后面表达式的运算；<br>只能操作boolean类型数据；<br>（2）&amp;不会出现短路，将整个表达式都运算。既可以操作boolean数据还可以操作数。</p>
<p>5、标示符命名规则：<br>由数字(0-9)，大小写英文字母，以及_和$组成。<br>不能以数字开头。<br>不能使用关键字来自定义命名。</p>
<p>6、数据类型：<br>(1)基本数据类型(4类8种)：<br>整数类型：byte、short、int、long<br>浮点数类型：float、double<br>字符类型：char<br>布尔类型：boolean(ture false)<br>(2)引用数据类型：<br>类<br>接口<br>数组</p>
<p>7、类型转换<br>精度从高到低 double float long int short(char) byte<br>(1)自动类型转换 将一个低精度—高精度<br>(2)强制类型转换 将一个高精度—低精度(精度会下降)</p>
<p>8、java语言的三种技术架构<br>J2EE：企业版<br>是为开发企业环境下的应用程序提供的一套解决方案。<br>该技术体系中包含的技术如 Servlet、Jsp等，主要针对于Web应用程序开发。<br>J2SE：标准版<br>是为开发普通桌面和商务应用程序提供的解决方案。<br>该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发。<br>比如Java版的扫雷。<br>J2ME：小型版<br>是为开发电子消费产品和嵌入式设备提供的解决方案。<br>该技术体系主要应用于小型电子消费类产品，如手机中的应用程序等。</p>
<p>9、java的跨平台性：<br>通过Java语言编写的应用程序在不同的系统平台上都可以运行。<br>跨平台的原因：<br>只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine)即可。<br>由JVM来负责Java程序在该系统中的运行。</p>
<p>10、有符号数据的表示法(次重点)<br>原码，反码(原码取反)，补码(反码+1)。</p>
<p>11、函数<br>定义：函数就是定义在类中的具有特定功能的一段独立小程序。<br>特点：<br>定义函数可以将功能代码进行封装<br>便于对该功能进行复用<br>函数只有被调用才会被执行<br>函数的出现提高了代码的复用性<br>对于函数没有具体返回值的情况，返回值类型用关键字void表示，<br>那么该函数中的return语句如果在最后一行可以省略不写。<br>函数的应用两个明确：<br>明确要定义的功能最后的结果是什么？<br>明确在定义该功能的过程中，是否需要未知内容参与运算</p>
<p>12、重载：<br>概念：在同一个类中，允许存在一个以上的同名函数，只要它们的参数个数或者参数类型不同即可。<br>特点：与返回值类型无关，只看参数列表(参数类型以及参数个数)。<br>好处：方便于阅读，优化了程序设计。    </p>
<p>13、数组：<br>概念：同一种数据类型的集合。<br>好处：可以自动给数组中的元素从0开始编号，方便操作这些元素。</p>
<p>14、内存结构：<br>栈内存：用于存储局部变量，当数据使用完，所占空间会自动释放。<br>堆内存：数组和对象，通过new建立的实例都存放在堆内存中。<br>方法区：静态成员、构造函数、常量池、线程池<br>本地方法区：window系统占用<br>寄存器：</p>
<p>二、面向对象<br>1、面向对象思想：<br>(1)概述：面向对象是相对于面向过程而言的，面向过程强调的是功能，面向对象强调的是将功能封装进对象，<br>强调具备功能的对象；<br>(2)思想特点：<br>A:是符合人们思考习惯的一种思想；<br>B:将复杂的事情简单化了；<br>C:将程序员从执行者变成了指挥者；</p>
<p>比如我要达到某种结果，我就寻找能帮我达到该结果的功能的对象，如我要洗衣服我就买洗衣机，<br>至于怎么洗我不管。<br>(3)特征：<br>封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式<br>继承: 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义<br>这些属性和行为，只要继承那个类即可。<br>多态: 一个对象在程序不同运行时刻代表的多种状态，父类或者接口的引用指向子类对象<br>2、类和对象：<br>类：对现实世界中某类事物的描述,是抽象的，概念上的定义。<br>对象：事物具体存在的个体。</p>
<p>3：成员变量和局部变量的区别(重点)<br>(1)作用域<br>成员变量：针对整个类有效。<br>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)<br>(2)存储位置<br>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。<br>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。<br>当方法调用完，或者语句结束后，就自动释放。<br>(3)初始值<br>成员变量：有默认初始值。<br>局部变量：没有默认初始值，使用前必须赋值。</p>
<p>4、匿名对象<br>(1)匿名对象就是没有名字的对象。是对象的一种简写形式。<br>(2)应用场景<br>A:只调用一次类中的方法。<br>B:可以作为实际参数在方法传递中使用</p>
<p>5、封装：<br>指隐藏对象的属性和实现细节，仅对外提供公共访问方式；比如电脑机箱、笔记本等<br>好处：<br>将变化隔离；<br>方便使用；<br>提高复用性；<br>提高安全性</p>
<p>6、关键字private：封装在代码中的体现<br>(1)私有的意思，权限修饰符<br>(2)用来修饰成员变量和成员函数<br>(3)用private修饰的成员只在本类中有效<br>(4)私有是封装的一种体现</p>
<p>7、构造方法：<br>(1)特点：<br>方法名与类名相同<br>没有返回类型<br>没有返回值<br>(2)作用：构造函数是用于创建对象，并对其进行初始化赋值，对象一建立就自动调用相对应的构造函数，<br>(3)构造方法的注意事项:<br>A:如果一个自定义类没有构造方法，系统会默认给出一个无参构造方法。<br>B:如果一个自定义类提供了构造方法，那么，系统将不再给出无参构造方法。<br>这个时候，你可以不使用无参构造方法。<br>如果你想使用，那么，就必须手动给出无参构造方法。</p>
<p>建议：一般情况下，我们的自定义类都要手动给出无参构造方法。<br>(4)构造方法和成员方法的区别<br>A:格式区别<br>构造方法和类名相同，并且没有返回类型，也没有返回值。<br>普通成员方法可以任意起名，必须有返回类型，可以没有返回值。<br>B:作用区别<br>构造方法用于创建对象，并进行初始化值。<br>普通成员方法是用于完成特定功能的。<br>C:调用区别<br>构造方法是在创建对象时被调用的，一个对象建立，只调用一次相应构造函数<br>普通成员方法是由创建好的对象调用，可以调用多次</p>
<p>8、构造代码块：<br>(1)作用：给对象进行初始化，对象一建立就执行，而且优先于构造函数执行<br>(2)构造代码块和构造函数的区别：<br>构造代码块是给所有不同对象的共性进行统一初始化<br>构造函数是给对应的对象进行初始化</p>
<p>9、this关键字<br>(1)this关键字代表本类对象的一个引用，谁调用this所在的方法，this就代表谁<br>(2)this的使用场景<br>A:用于区分同名成员变量和局部变量；<br>B:在定义函数时，该函数内部要用到调用该函数的对象时，因为此时对象还没建立，故this代表此对象<br>B:构造函数间调用<br>**这个时候，this(参数)必须作为第一条语句存在。</p>
<p>10、Person p = new Person();在内存中做了哪些事情。<br>(1)将Person.class文件加载进内存中。<br>(2)如果p定义在主方法中，那么，就会在栈空间开辟一个变量空间p。<br>(3)在堆内存给对象分配空间。<br>(4)对对象中的成员进行默认初始化。<br>(5)对对象中的成员进行显示初始化。<br>(6)调用构造代码块对对象进行初始化。(如果没有就不执行)<br>(7)调用构造方法对对象进行初始化。对象初始化完毕。<br>(8)将对象的内存地址赋值给p变量，让p变量指向该对象。</p>
<p>11、static关键字：<br>(1)静态的意思，用来修饰成员变量和成员函数<br>(2)静态的特点:<br>随着类的加载而加载<br>优先于对象存在<br>对所有对象共享<br>可以被类名直接调用<br>(3)静态的注意事项<br>A:静态方法只能访问静态成员<br>为什么：因为静态的内容是随着类的加载而加载，它是先进内存的。<br>B:静态方法中不能使用this,super关键字<br>C:主方法是静态的<br>public static void main(String[] args)<br>public:公共的意思，是最大权限修饰符。<br>static:由于jvm调用main方法的时候，没有创建对象。<br>只能通过类名调用。所以，main必须用static修饰。<br>void:由于main方法是被jvm调用，不需要返回值。用void修饰。<br>main:main是主要的意思，所以jvm采用了这个名字。是程序的入口。</p>
<p>String[]:字符串数组<br>args:数组名</p>
<p>在运行的时候，通过java命令给args数组赋值。<br>格式：java MainTest hello world itcast<br>(4)静态变量和成员变量的区别<br>A：调用方式<br>静态变量也称为类变量，可以直接通过类名调用。也可以通过对象名调用。<br>这个变量属于类。<br>成员变量也称为实例变量，只能通过对象名调用。这个变量属于对象。<br>B：存储位置<br>静态变量存储在方法区长中的静态区。<br>成员变量存储在堆内存。<br>C：生命周期<br>静态变量随着类的加载而存在，随着类的消失而消失。生命周期长。<br>成员变量随着对象的创建而存在，随着对象的消失而消失。<br>D：与对象的相关性<br>静态变量是所有对象共享的数据。<br>成员变量是每个对象所特有的数据。<br>(5)静态的优点和弊端<br>优点：<br>对对象的共享数据进行单独空间的存储，节省内存，没有必要每个对象都存储一份<br>可直接被类名调用<br>弊端：<br>生命周期过长，随着类的消失而消失<br>访问出现权限，即静态虽好但只能访问静态<br>(6)什么使用使用静态呢？<br>A:当所有对象共享某个数据的时候，就把这个成员变量定义为静态修饰的。<br>B:当某个方法没有访问该类中的非静态成员，就可以把这个方法定义为静态修饰。</p>
<p>静态的生命周期比较长，所以一般不推荐使用。<br>(7)静态代码块<br>A:它只执行一次，它比main还先执行。<br>B:执行顺序<br>静态代码块–构造代码块–构造方法</p>
<p>12、制作API(次重点)<br>API(全拼):Application Program Interface 应用程序编程接口。<br>(1)类中的内容需要用文档注释。<br>(2)使用JDK\bin目录下的javadoc工具。<br>格式:javadoc -d 目录 -author -version ArrayTool.java</p>
<p>13、单例设计模式：<br>(1)设计模式：<br>解决某类问题行之有效的方法，是一种思想，是规律的总结<br>(2)用来保证某个类在内存中只有一个对象<br>(3)保证唯一性的思想及步骤<br><strong>为了避免其他程序建立该类对象，先禁止其他程序建立该类对象，即将构造函数私有化
</strong>为了其他程序访问到该类对象，须在本类中创建一个该类私有对象<br>**为了方便其他程序访问到该类对象，可对外提供一个公共访问方式</p>
<p>比如API中的Runtime类就是单例设计模式。</p>
<p>(4)单例设计模式的两种方式<br>A:饿汉式 当类加载的时候，就创建对象。</p>
<p>复制代码<br>class Student<br>{<br>private Student(){}</p>
<p>private static final Student s = new Student();</p>
<p>public static Student getInstance()<br>{<br>return s;<br>}<br>}<br>复制代码</p>
<p>B:懒汉式 当使用的使用，才去创建对象。</p>
<p>复制代码<br>class Student<br>{<br>private Student(){}</p>
<p>private static final Student s = null;</p>
<p>public static Student getInstance()<br>{<br>if(s==null)<br>{<br>复制代码</p>
<p>//线程1就进来了，线程2就进来了。<br>s = new Student();<br>}<br>return s;<br>}<br>}<br>饿汉式和懒汉式的区别：<br><strong><br>饿汉式是类一加载进内存就创建好了对象；<br>懒汉式则是类才加载进内存的时候，对象还没有存在，只有调用了getInstance()方法时，<br>对象才开始创建。
</strong><br>懒汉式是延迟加载，如果多个线程同时操作懒汉式时就有可能出现线程安全问题，解决线程安全问题<br>可以加同步来解决。但是加了同步之后，每一次都要比较锁，效率就变慢了，<br>所以可以加双重判断来提高程序效率。<br>注：开发常用饿汉式，因为饿汉式简单安全。懒汉式多线程的时候容易发生问题</p>
<p>14、Math类的使用(重点)<br>(1)数学操作类:该类没有构造函数，方法均为静态的<br>(2)掌握内容<br>A:成员变量<br><strong>E：比任何其他值都更接近e（即自然对数的底数）的double值。
</strong>PI：比任何其他值都更接近pi（即圆的周长与直径之比）的double值。<br>B:成员方法<br><strong>static double abs(double a)<br>返回 double 值的绝对值。返回绝对值
</strong>static double ceil(double a)<br>返回最小的（最接近负无穷大）double 值，该值大于等于参数，并等于某个整数。<br><strong>static double floor(double a)<br>返回最大的（最接近正无穷大）double 值，该值小于等于参数，并等于某个整数。 
</strong>max：返回两个值中较大的那个<br><strong>min：返回两个值中较小的那个
</strong>static long round(double a) 返回最接近参数的 long。<br>static int round(float a) 返回最接近参数的 int。<br><strong>static double random()<br>返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。 
</strong>static double pow(double a, double b)<br>返回第一个参数的第二个参数次幂的值。<br><strong>static double sqrt(double a)<br>返回正确舍入的 double 值的正平方根。<br>15、Random类的使用(重点)<br>(1)产生随机数的类<br>(2)掌握内容<br>A:构造方法
</strong>Random() 创建一个新的随机数生成器。<br><strong>Random(long seed) 使用单个 long 种子创建一个新的随机数生成器。<br>B:成员方法
</strong>int nextInt() 返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。<br><strong>int nextInt(int n) 返回一个伪随机数，它是取自此随机数生成器序列的、<br>在 0（包括）和指定值（不包括）之间均匀分布的 int 值。<br>16、Scanner类的使用<br>(1)可以获取从键盘的输入数据<br>(2)掌握内容<br>构造方法：<br>Scanner(InputStream source) 构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。<br>如：Scanner sc = new Scanner(System.in);<br>方法摘要<br>sc.nextInt();获取整型数据<br>sc.nextLine();获取字符串数据<br>17、继承(重点)<br>(1)把很多类的相同特征和行为进行抽取，用一个类来描述。让多个类和这个类产生一个关系。<br>这样的话，多个类就可以省略很多代码。这个关系就是继承。java中用extends关键字表示。<br>(2)继承的体系结构<br>A:多个具体的对象，不断的向上抽取共享的内容，最终形成了一个体系。这个体系叫做继承体系。<br>B:继承体系的学习和使用原则
</strong>学习顶层的内容。因为他是整个体系的共性内容。<br>**创建子类使用。也就是使用底层的具体对象。<br>(3)继承的特点:<br>A:java中只能单继承，没有多继承。<br>B:java可以有多重(层)继承。<br>(4)继承的好处：<br>继承的出现提高了代码的复用性。<br>继承的出现让类与类之间产生了关系，提供了多态的前提。<br>(5)子父类中的成员关系<br>A:成员变量<br>在子类方法中使用一个变量时：<br>首先，在方法的局部变量中找这个变量，有则使用。<br>否则，在本类中找成员变量，有则使用。<br>否则，在父类中找成员变量，有则使用。<br>否则，报错。<br>B:成员方法<br>用子类对象使用一个方法时。<br>首先，在子类中找这个方法，有则使用。<br>否则，在父类中找这个方法，有则使用。<br>否则，报错。</p>
<p>重写和重载的区别？<br>重载：在同一类中。方法名相同，参数列表不同。重载可以改变返回类型。<br>重写：在不同类中(子父类中)。<br>方法声明相同(返回类型，方法名，参数列表均相同)。<br>重写需要注意：<br><strong>子类方法的访问权限要大于等于父类方法的访问权限。
</strong>静态只能重写静态。但是这种情况一般不会出现。</p>
<p>构造方法<br><strong>子类的实例化过程<br>*</strong>子类创建对象时，会先去创建父类的对象。<br>默认是去调用父类的无参构造方法。<br><strong><em>子类构造方法中，第一行默认是super()
</em></strong>为什么子类中第一行会默认有super()<br>因为他继承父类的成员使用，使用前这些成员必须初始化，<br>而他们是父类的成员，所以，必须通过父类进行初始化。<br>所以，会先创建一个父类的对象。<br><strong>当父类没有无参构造方法时<br>必须使用this或者super调用其他的构造方法。<br>(6)this和super的区别<br>this:代表本类对象的引用。<br>super:代表父类的存储空间。<br>18、final关键字(重点)<br>(1)最终的意思，可以用于修饰类，方法，变量。<br>(2)final修饰的类不能被继承。<br>final修饰的方法不能被重写。<br>final修饰的变量是一个常量。只能被赋值一次。<br>内部类只能访问被final修饰的局部变量。<br>19、抽象类(重点)<br>(1)多个类有相同的方法声明，但是方法体不一样。这个时候，我们考虑把方法声明进行抽取。<br>让子类继承后，自己去实现方法体。没有方法体的方法，我们需要用抽象标志下。<br>抽象的关键字是：abstract。<br>(2)抽象类：<br>该方法称为抽象方法，包含抽象方法的类就是抽象类。<br>(3)抽象类的特点：<br>A:抽象类和抽象方法都要用abstract进行修饰<br>B:抽象类不能被实例化<br>C:抽象类中不一定有抽象方法，但是，有抽象方法的类一定是抽象类。<br>(4)抽象类中数据的特点<br>A:成员变量<br>抽象类中可以有变量，也可以有常量。<br>B:成员方法<br>抽象类中可以有抽象方法，也可以有非抽象方法。<br>C:构造方法<br>抽象类是一个类，所以，它有构造方法。<br>虽然本身不能实例化。但是可以给子类实例化使用。<br>(5)抽象类中的问题<br>A:抽象类中是否有构造方法？能不能被实例化？如果不能，为什么有构造方法？<br>抽象类有构造方法。<br>抽象类不能被实例化。<br>抽象类中的构造方法供子类实例化调用。<br>B:抽象关键字abstract不可以和哪些关键字共存？
</strong>private:<br>私有内容子类继承不到，所以，不能重写。<br>但是abstract修饰的方法，要求被重写。两者冲突。<br><strong>final<br>final修饰的方法不能被重写。<br>而abstract修饰的方法，要求被重写。两者冲突。    
</strong>static<br>假如一个抽象方法能通过static修饰，那么这个方法，就可以直接通过类名调用。<br>而抽象方法是没有方法体的，这样的调用无意义。所以，不能用static修饰。<br>C:抽象类中可不可以没有抽象方法？如果可以，这样的类有什么用吗？<br>抽象类可以没有抽象方法。<br>抽象类中没有抽象方法的作用，只是为了不让别的类建立该抽象类对象。这个在awt中有体现。<br>20、接口interface<br>(1)当一个类中的方法都是抽象的时候，java提供了另一种表示方式，叫接口。<br>用interface关键字表示。类与接口关系用implements表示。<br>(2)接口的成员特点<br>A:成员变量<br>是常量，默认修饰 public static final<br>B:成员方法<br>都是抽象的，默认修饰 public abstract<br>(3)关系<br>A:类与类的关系<br>是继承关系。类与类只能单继承，可以多重继承。<br>B:类和接口的关系<br>是实现关系。类可以多实现接口。<br>类在继承一个类的同时，可以实现多个接口。<br>C:接口和接口的关系<br>是继承关系。接口可以多继承接口。<br>(4)接口的特点<br>A:是对外暴露的规则<br>B:是功能的扩展<br>C:接口的出现降低耦合性。<br>耦合(类与类之间的关系)<br>内聚(类完成功能的能力)<br>编程规范：低耦合，高内聚。<br>D:接口可以多实现。如：CPU和主板、笔记本的USB插口、插座<br>(5)接口和抽象类的区别<br>A：抽象类只能被单继承<br>接口可以多实现,接口的出现避免了多继承的局限性。<br>B：抽象类中的数据特点：<br>成员变量：可以是变量，也可以是常量<br>成员方法：可以是抽象方法，也可以是非抽象方法<br>构造方法：有构造方法<br>接口中的数据特点：<br>成员变量：是常量。默认修饰 public static final<br>成员方法：都是抽象方法。都有默认修饰 public abstract<br>构造方法：没有构造方法<br>C：抽象类中定义的是继承体系中的共性功能。<br>接口中定义的是继承体系中的扩展功能。<br>D：抽象类被继承是”is a”关系:xx是yy的一种<br>接口被实现是”like a”关系:xx像yy的一种<br>21、多态：<br>(1)同一个对象，在程序不同时刻的多种运行状态。举例：动物，狗是狗，狗是动物。水(气态，液态，固态)<br>(2)多态前提<br>A:存在着继承或者实现关系<br>B:有方法的重写<br>C:父类(接口)引用指向子类(实现)对象<br>(3)多态的好处和弊端：<br>好处：多态的存在提高了程序的扩展性和后期可维护性<br>弊端：虽然可以预先使用，但是只能访问父类中已有的功能，运行的是后期子类的功能内容。<br>不能预先使用子类中定义的特有功能。<br>(4)多态中对象调用成员的特点<br>Fu f = new Zi();</p>
<p>A:成员变量<br>编译看左边，运行看左边<br>B:成员方法<br>编译看左边，运行看右边<br>C:静态方法<br>编译看左边，运行看左边<br>(5)多态的思想<br>指挥同一批对象做事情。举例：带兵打仗，下课等。<br>22、instanceof关键字<br>A:用于判断某个对象是否是某种类型。<br>B:格式<br>对象名 instanceof 子类(实现)名<br>23、Object类：<br>(1)是所有类的根类，超类。<br>java中提供的类以及我们自定义的类都直接或者间接的继承自Object类。<br>(2)Object类中的方法<br>A:void finalize()<br>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。<br>B:Class getClass()<br>获取对象的字节码文件的描述类，后面再讲反射的时候还会在说这个类。<br>String name = s.getClass().getName();<br>C:int hashCode()<br>获取对象的哈希值。其实就是对象的内存地址值十进制表示<br>D:String toString()<br>返回对象的字符串表示。<br>表示格式：<br>getClass().getName()+”@”+Integer.toHexString(hashCode());</p>
<p>一般我们输出对象名的时候，其实底层调用的就是该对象的toString()方法。<br>这种返回没有意义，所以，我们会重写这个方法，显示类的成员变量信息。<br>E:boolean equals(Object obj)<br>用于比较两个对象的地址值是否相同。<br>我们获取对象后，比较它的地址值意义不大。所以也会对这个方法进行重写。<br>重写要完成什么功能，是根据需求定的。<br>(3)==和equals的用法：<br>A:==怎么用？<br><strong>可以用于比较基本数据类型，比较的就是基本数据类型的值是否相等。
</strong>可以用于比较引用数据类型，比较的是对象的地址值是否相等。<br>B:equals怎么用？<br>equals只能用于比较引用数据类型的。<br><strong>Object提供的equals是用于比较对象地址值是否相同。
</strong>自定义类中，如果重写了equals方法，那么就是按照你自己的需求来比较的。</p>
<p>24、package关键字<br>(1)包：其实就是文件夹。用于区分不同包下相同的类名。<br>(2)好处：<br>A：对类文件进行分类管理。<br>B：给类提供了多层命名空间<br>aaa.Demo<br>bbb.Demo<br>C：写在程序文件的第一行。<br>D：包也是一种封装形式。<br>25、import关键字<br>(1)导入包的关键字<br>(2)格式：<br>import 包名;<br>(3)注意：<br>A:一个程序文件中只有一个package，可以有多个import。<br>B:用来导包中的类，不导入包中的包。<br>C:通常写import mypack.Demo，明确自己使用的类。<br>(4)关键字的顺序<br>类，包，导包这些关键的顺序。<br>包 – &gt; 到包 – &gt; 类<br>26、不同修饰符可以修饰哪些内容<br>本类中    同一个包中 不同包中的子类中 不同包中<br>private    OK<br>默认    OK    Ok<br>protected    OK    Ok    OK<br>public    OK    Ok    OK    Ok</p>
<p>类    构造方法    成员变量    成员方法<br>private    OK    OK    OK<br>默认    Ok    Ok    Ok    OK<br>protected    OK    OK    Ok<br>public Ok    Ok    OK    OK<br>static    OK    Ok<br>final    Ok    OK    OK<br>abstract    Ok    OK</p>
<p>一般格式：<br>成员变量：<br>权限修饰符+static/final+数据类型+成员变量名<br>public static final int NUM = 10;</p>
<p>成员方法：<br>权限修饰符+static/final/abstract+返回类型+方法名<br>27、内部类(次重点)<br>(1)把一个类定义在某个类中的，这个类就被称为内部类，内置类，嵌套类。<br>(2)访问特点：<br>A:内部类可以直接访问外部类中的成员，因为内部类持有外部类的引用，<br>格式为：外部类名.this<br>B:外部类要想访问内部类的成员，必须创建对象访问。<br>(3)内部类的访问格式：<br>A:当内部类定义在外部类的成员位置，而且非私有，则可以在其他外部类中直接建立内部类对象<br>格式：外部类名.内部类名 变量名 = new 外部类对象.内部类对象<br>如：Outer.Inner in = new Outer().new Inner()<br>B:当内部类在外部类成员位置，且被static修饰时<br><strong>外部其他类可直接访问静态内部类的非静态成员<br>格式：new 外部类名.内部类名().内部类成员<br>如：new Outer.Inner().function();
</strong>外部其他类可直接访问静态内部类的静态成员<br>格式：new 外部类名.内部类名.内部类成员<br>如：new Outer.Inner.function();<br>(4)什么使用时候内部类呢？<br>假如有A类和B类，A类想直接访问B类的成员，B类访问A类成员的时候，<br>需要创建A类对象进行访问，这个时候，就可以把A类定义为B类的内部类。<br>(5)内部类的位置<br>A:成员位置<br><strong>可以被private修饰(Body，Heart)
</strong>可以被static修饰。(它访问的外部类的成员必须是静态的)<br>B:局部位置<br>**可以直接访问外部类中的成员，因为还持有外部类的持用<br>也可以直接访问局部成员，但是局部成员要用final修饰。<br>注意：局部内部类不能用private和static修饰<br>(6)通过class文件我们就可以区分是否带有内部类，以及内部类的位置<br>Outer$Inner:成员内部类<br>Outer$1Inner:局部内部类<br>28、匿名内部类(局部内部类的简写) (重点)<br>(1)前提：继承一个类或者实现一个接口<br>(注意不要弄混匿名内部类的前提和多态的前提)<br>(2)格式：<br>new 父类名或者接口名()<br>{<br>重写父类方法或者实现接口中的方法。<br>也可以自定义其他方法。<br>};<br>(3)什么时候定义匿名内部类？<br>匿名内部类只是为了简化书写，匿名内部类有局限，通常定义匿名内部类时，该类方法不超过3个<br>(4)匿名内部类的好处和弊端：<br>好处：简化代码书写<br>弊端：<br>不能直接调用自己的特有方法<br>不能执行强转换动作<br>如果该类里面方法较多，不允许使用匿名内部类<br>29、模板设计模式：<br>在定义功能时，功能的一部分是确定的，有一部分是不确定的，而且确定的部分在使用不确定的部分，<br>可将不确定的部分暴露出去，由该类的子类去完成。<br>如：求一段程序的运行时间例子。<br>30、异常<br>(1)程序运行过程中的不正常现象就叫异常。<br>(2)导致程序运行不正常的现象有很多，所以，就有很多的异常对象。<br>而这些异常对象存在着共性的内容，所以，可以不断的进行抽取。最终形成了异常的体系结构。<br>异常体系的根类是:Throwable<br>Throwable：<br>|–Error:重大的问题，我们处理不了。也不需要编写代码处理。比如说内存溢出。<br>|–Exception:一般性的错误，是需要我们编写代码进行处理的。<br>|–RuntimeException:运行时异常，这个我们也不需要处理。<br>其实就是为了让他在运行时出问题，然后我们回来修改代码。<br>(3)异常的分类<br>异常有两种：<br>编译时被检测异常：<br>该异常在编译时，如果没有处理(没有抛也没有try)，编译失败。<br>该异常被标识，代表这可以被处理。<br>运行时异常(编译时不检测)<br>在编译时，不需要处理，编译器不检查。<br>该异常的发生，建议不处理，让程序停止。需要对代码进行修正。<br>(4)异常体系的特点：<br>异常体系中的所有类及其子类对象都具备可抛性。也就是说可以被throw和throws关键字所操作。<br>(5)main方法是如何处理异常的。<br>A:在main里面编写代码进行处理<br>B:交给jvm自己进行处理。采用的是jvm的默认处理方式。<br>其实就是相当于调用了异常对象的printStackTrace()方法。<br>(6)Throwable类的学习<br>getMessage():获取异常信息，返回字符串。<br>toString():获取异常类名和异常信息，返回字符串。<br>printStackTrace():获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。<br>(7)异常的处理·<br>A:try…catch…finally</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/09/java基础/" data-id="cju97sbz50000hcg8hzz3ur74" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-demo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/09/demo/" class="article-date">
  <time datetime="2019-04-09T01:58:15.000Z" itemprop="datePublished">2019-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/09/demo/">demo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>aaaaaaaaaaaaaaaaa</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/09/demo/" data-id="cju94znmj0001rsg83i9w3bx2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/09/hello-world/" class="article-date">
  <time datetime="2019-04-09T01:16:27.696Z" itemprop="datePublished">2019-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/09/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/09/hello-world/" data-id="cju94znmc0000rsg8qbkrofy1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/09/java基础/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/04/09/demo/">demo</a>
          </li>
        
          <li>
            <a href="/2019/04/09/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>